package generator

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

const (
	staticPbjsFileSuffix = ".pb"
	twirpFileExtension   = ".twirp.js"
)

// Generator is a JavaScript code generator for Twirp services.
type Generator struct {
	buf      bytes.Buffer
	genFiles []*pluginpb.CodeGeneratorResponse_File
}

// New returns a new generator value.
func New() *Generator {
	return &Generator{
		genFiles: make([]*pluginpb.CodeGeneratorResponse_File, 0),
	}
}

// Run reads a CodeGeneratorRequest from os.Stdin, invokes code generation method
// of given generator with it, and writes the resulting CodeGeneratorResponse to os.Stdout.
func (g *Generator) Run(opts protogen.Options, f func(*protogen.Plugin) error) {
	if err := g.run(opts, f); err != nil {
		fmt.Fprintf(os.Stderr, "%s: %v\n", filepath.Base(os.Args[0]), err)
		os.Exit(1)
	}
}

// GenerateFile generates a Twirp JavaScript client from a Protobuf file.
func (g *Generator) GenerateFile(f *protogen.File, args []string) {
	g.genFiles = append(g.genFiles, g.generateFile(f.Desc, args))
	g.buf.Reset()
}

// P prints a line with given arguments to the generator's buffer.
func (g *Generator) P(v ...interface{}) {
	for _, x := range v {
		fmt.Fprint(&g.buf, x)
	}
	fmt.Fprintln(&g.buf)
}

func (g *Generator) generateFile(fd protoreflect.FileDescriptor, args []string) *pluginpb.CodeGeneratorResponse_File {
	pbjsFormat := args[0]
	g.generateHeader(fd)
	g.P()
	g.P("import Axios from 'axios';")
	switch pbjsFormat {
	case "json":
		g.P("import protobuf from 'protobufjs/light';")
		g.P("import { newRPC } from 'pbjs-twirp-rpc';")
		g.P()
		g.generateJSONSourceCode(fd, args)
	case "static-module":
		g.P("import { newRPC } from 'pbjs-twirp-rpc';")
		g.P()
		g.generateStaticSourceCode(fd, args)
	default:
		g.buf.Reset()
		return nil
	}
	g.generateCommonCode(fd, args)
	return &pluginpb.CodeGeneratorResponse_File{
		Name:    proto.String(filePathWithoutProtoExtension(fd) + twirpFileExtension),
		Content: proto.String(g.buf.String()),
	}
}

func (g *Generator) generateHeader(fd protoreflect.FileDescriptor) {
	g.P("// Code generated by protoc-gen-twirp_javascript. DO NOT EDIT.")
	g.P("// Source: ", fd.Path())
}

func (g *Generator) generateJSONSourceCode(fd protoreflect.FileDescriptor, args []string) {
	// This plugin assumes its output will be written in the same directory as the
	// file generated by pbjs. However, this assumption is only used to generate
	// import paths in the resulting Twirp service file, the plugin does not care
	// if the file generated by pbjs exists or not at the time of its execution.
	pbjsFile := fileNameWithoutProtoExtension(fd) + ".json"
	g.P("const json = require('./", pbjsFile, "');")
	g.P("const root = protobuf.Root.fromJSON(json);")
	for i := 0; i < fd.Services().Len(); i++ {
		sd := fd.Services().Get(i)
		g.P("const ", lowerCamelCase(sd.Name()), " = root.lookupService('", sd.FullName(), "');")
	}
	g.P()
	g.P("const rpcMethodNameLookupFn = fn => {")
	g.P("\treturn fn.name;")
	g.P("};")
}

func (g *Generator) generateStaticSourceCode(fd protoreflect.FileDescriptor, args []string) {
	// See comments in generateJSONSourceCode.
	// Note: the .js extension is omitted as it is implicit in ES6 import syntax.
	pbjsFile := fileNameWithoutProtoExtension(fd) + staticPbjsFileSuffix
	g.P("import ", importDirectiveFromProtoPackage(fd.Package()), "'./", pbjsFile, "';")
	g.P()
	g.P("const rpcMethodNameLookupFn = fn => {")
	for i := 0; i < fd.Services().Len(); i++ {
		sd := fd.Services().Get(i)
		for j := 0; j < sd.Methods().Len(); j++ {
			md := sd.Methods().Get(j)
			g.P("\tif (fn === ", sd.FullName(), ".prototype.", lowerCamelCase(md.Name()), ") {")
			g.P("\t\treturn '", md.Name(), "';")
			g.P("\t}")
		}
	}
	g.P()
	g.P("\tthrow new Error('unknown RPC method');")
	g.P("};")
}

func (g *Generator) generateCommonCode(fd protoreflect.FileDescriptor, args []string) {
	pbjsFormat, twirpVersion := args[0], args[1]
	var urlPrefix string
	if twirpVersion == "v5" {
		urlPrefix = "/twirp"
	}

	for i := 0; i < fd.Services().Len(); i++ {
		sd := fd.Services().Get(i)
		svcName := sd.Name()
		lccSvcName := lowerCamelCase(svcName)

		g.P()
		g.P("export const ", lccSvcName, "Prefix = '", urlPrefix, "/", sd.FullName(), "/';")
		g.P("export const create", svcName, "Client = (baseURL, opts) => {")
		g.P("\tconst defaultOpts = {")
		g.P("\t\tbaseURL: baseURL + ", lccSvcName, "Prefix,")
		g.P("\t\theaders: {")
		g.P("\t\t\tAccept: 'application/protobuf'")
		g.P("\t\t}")
		g.P("\t};")
		g.P("\tconst axiosOpts = { ...defaultOpts, ...opts };")
		g.P("\tconst axios = Axios.create(axiosOpts);")
		switch pbjsFormat {
		case "json":
			g.P("\treturn ", lccSvcName, ".create(newRPC(axios, rpcMethodNameLookupFn));")
		case "static-module":
			g.P("\treturn ", sd.FullName(), ".create(newRPC(axios, rpcMethodNameLookupFn));")
		}
		g.P("};")
	}
}

func (g *Generator) run(opts protogen.Options, f func(*protogen.Plugin) error) error {
	if len(os.Args) > 1 {
		return fmt.Errorf("unknown argument %q (this program should be run by protoc, not directly)", os.Args[1])
	}
	in, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		return err
	}
	req := new(pluginpb.CodeGeneratorRequest)
	if err := proto.Unmarshal(in, req); err != nil {
		return err
	}
	plugin, err := opts.New(req)
	if err != nil {
		return err
	}

	var resp *pluginpb.CodeGeneratorResponse
	if err := f(plugin); err != nil {
		resp = &pluginpb.CodeGeneratorResponse{Error: proto.String(err.Error())}
	} else {
		resp = &pluginpb.CodeGeneratorResponse{File: g.genFiles}
	}
	out, err := proto.Marshal(resp)
	if err != nil {
		return err
	}
	if _, err := os.Stdout.Write(out); err != nil {
		return err
	}
	return nil
}

func fileNameWithoutProtoExtension(fd protoreflect.FileDescriptor) string {
	return filepath.Base(filePathWithoutProtoExtension(fd))
}

func filePathWithoutProtoExtension(fd protoreflect.FileDescriptor) string {
	path := fd.Path()
	path = strings.TrimSuffix(path, ".protodevel")
	path = strings.TrimSuffix(path, ".proto")
	return path
}

func importDirectiveFromProtoPackage(pkg protoreflect.FullName) string {
	substrings := strings.Split(string(pkg), ".")
	if len(substrings) > 0 {
		return fmt.Sprint("{ ", substrings[0], " } from ")
	}
	return ""
}

func lowerCamelCase(n protoreflect.Name) string {
	s := string(n)
	return strings.ToLower(s[0:1]) + s[1:]
}
